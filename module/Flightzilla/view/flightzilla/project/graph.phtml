<?php echo $this->render('flightzilla/index/partial/header.phtml'); ?>

<div class="row-fluid">
    <?php
    echo $this->partial('flightzilla/project/partial/sidebar.phtml', array(
          'sHeading' => 'Project-Graphs',
          'aStack' => array(),
    ));
    ?>

    <div id="project-canvas" class="span10">

    </div>
</div>

<?php $this->inlineScript()->appendFile($this->basePath() . '/vendor/d3.min.js'); ?>
<script type="text/javascript">
    $(function() {
        var xScale, yScale, centered, g, svg,
            width = 1280,
            height = 640,
            xAxis = 'revenue',
            yAxis = 'complexity',
            radius = 'probability',
            color = 'risk',
            aColors = [
                '#bbb',
                '#2ca02c',
                '#98df8a',
                '#bd9e39',
                '#ff7f0e',
                '#d62728'
            ];

        d3.json(BASE_URL + '/flightzilla/project/graphdata', function(data) {
            var bounds = getBounds(data, 1);
            svg = d3.select("#project-canvas")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            g = svg.append('g').classed('chart', true).attr('transform', 'translate(80, -60)');

            // Hover-Label
            g.append('text')
                .attr({'id': 'label', 'x': 0, 'y': 100})
                .style({'font-size': '30px', 'font-weight': 'bold', 'fill': '#ddd'});

            // Labels
            g.append('text').attr({'id': 'xLabel', 'x': parseInt(width / 2), 'y': (height + 30), 'text-anchor': 'middle'}).text('Revenue');
            g.append('text').attr('transform', 'translate(-60, 330)rotate(-90)').attr({'id': 'yLabel', 'text-anchor': 'middle'}).text('Complexity');

            // Axes
            xScale = d3.scale.pow()
                .exponent(4 * parseFloat(bounds[xAxis].avg / bounds[xAxis].max))
                .domain([bounds[xAxis].min, bounds[xAxis].max])
                .range([20, (width - 30)]);

            yScale = d3.scale.linear()
                .domain([bounds[yAxis].min, bounds[yAxis].max])
                .range([(height - 40), 100]);

            // Data
            var borderColor = d3.scale.category20c();
            g.selectAll('circle')
                .data(data)
                .enter()
                .append('circle')
                .attr('cx', function(d) {
                    return isNaN(d[xAxis]) ? d3.select(this).attr('cx') : xScale(d[xAxis]);
                })
                .attr('cy', function(d) {
                    return isNaN(d[yAxis]) ? d3.select(this).attr('cy') : yScale(d[yAxis]);
                })
                .attr('r', function(d) {
                    return (isNaN(d[radius]) || isNaN(d[xAxis]) || isNaN(d[yAxis])) ? 0 : (12 + (3 * d[radius]));
                })
                .attr('fill', function(d, i) {
                    return aColors[d[color]];
                })
                .attr('stroke', function(d) {
                    return borderColor(d.id);
                })
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .on('mouseover', function(d) {
                    d3.select('svg g.chart #label')
                        .text(d.summary)
                        .transition()
                        .style('opacity', 1);
                })
                .on('mouseout', function(d) {
                    d3.select('svg g.chart #label')
                        .transition()
                        .duration(1500)
                        .style('opacity', 0);
                })
                .on('click', clickCircle);

            // Update correlation
            var xArray = _.map(data, function(d) {return d[xAxis];});
            var yArray = _.map(data, function(d) {return d[yAxis];});
            var c = getCorrelation(xArray, yArray);

            var x1 = xScale.domain()[0],
                y1 = c.m * x1 + c.b;
            var x2 = xScale.domain()[1],
                y2 = c.m * x2 + c.b;

            var line = d3.svg.line()
                .x(function(d) {
                    return xScale(d[xAxis]);
                })
                .y(function(d) {
                    return yScale(d[yAxis]);
                })
                .interpolate('basis-open');

            g.append("path")
                .style('opacity', 0)
                .data([data])
                .attr("d", line)
                .style("fill", "none")
                .style("stroke", "#000000")
                .attr("transform", "translate(" + [100, 100] + ")")
                .transition()
                .duration(1500)
                .style('opacity', 1);

            // Render axes
            g.append("g")
                .attr('transform', 'translate(0, 630)')
                .attr('id', 'xAxis')
                .call(function (s) {
                    s.call(d3.svg.axis().scale(xScale).orient("bottom"));
                });

            g.append("g")
                .attr('id', 'yAxis')
                .attr('transform', 'translate(-10, 0)')
                .call(function (s) {
                    s.call(d3.svg.axis().scale(yScale).orient("left"));
                });
        });

        function clickCircle(d) {
            var x = width / 2,
                y = height / 2,
                k = 1;

            if (d && centered !== d) {
                x = xScale(d[xAxis]);
                y = yScale(d[yAxis]);
                k = 4;
                centered = d;
            }
            else {
                centered = null;
            }

            g.transition().duration(1000).attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")");
        }

        function getBounds(d, paddingFactor) {
            // Find min and maxes (for the scales)
            paddingFactor = typeof paddingFactor !== 'undefined' ? paddingFactor : 1;

            var keys = _.keys(d[0]), b = {};
            _.each(keys, function(k) {
                b[k] = {
                    min: (_.min(d, k))[k],
                    max: (_.max(d, k))[k],
                    avg: (_.reduce(_.pluck(d, k), function(result, value) {
                        return result + value;
                    }) / _.size(d))
                };

                b[k].max > 0 ? b[k].max *= paddingFactor : b[k].max /= paddingFactor;
                b[k].min > 0 ? b[k].min /= paddingFactor : b[k].min *= paddingFactor;
            });

            return b;
        }

        function getCorrelation(xArray, yArray) {
            function sum(m, v) {return m + v;}
            function sumSquares(m, v) {return m + v * v;}
            function filterNaN(m, v, i) {
                if (!isNaN(v)) {
                    m.push(i);
                }

                return m;
            }

            // clean the data (because we know that some values are missing)
            var xNaN = _.reduce(xArray, filterNaN , []);
            var yNaN = _.reduce(yArray, filterNaN , []);
            var include = _.intersection(xNaN, yNaN);
            var fX = _.map(include, function(d) {return xArray[d];});
            var fY = _.map(include, function(d) {return yArray[d];});

            var sumX = _.reduce(fX, sum, 0);
            var sumY = _.reduce(fY, sum, 0);
            var sumX2 = _.reduce(fX, sumSquares, 0);
            var sumY2 = _.reduce(fY, sumSquares, 0);
            var sumXY = _.reduce(fX, function(m, v, i) {return m + v * fY[i];}, 0);

            var n = fX.length;
            var ntor = ( ( sumXY ) - ( sumX * sumY / n) );
            var dtorX = sumX2 - ( sumX * sumX / n);
            var dtorY = sumY2 - ( sumY * sumY / n);

            var r = ntor / (Math.sqrt( dtorX * dtorY )); // Pearson ( http://www.stat.wmich.edu/s216/book/node122.html )
            var m = ntor / dtorX; // y = mx + b
            var b = ( sumY - m * sumX ) / n;

            console.log({r: r, m: m, b: b});
            return {r: r, m: m, b: b};
        }
    });
</script>
